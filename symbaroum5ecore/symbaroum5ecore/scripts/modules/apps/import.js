// Set global module variables.
export const moduleKey = 'symbaroum5ecore'; // Module name. Important that this one is the exact same as the name of the module
const moduleTitle = 'Symbaroum 5E Ruins of Symbaroum - Core System'; // Module Title, is not referenced beyond giving a title to HTML dialog, so can be anything
const packageManifest = 'manifest.json'; // This is the manifest generated by the export script. Not necessary to alter unless the filename has been manually altered.
const sceneToActivate = 'System Cover'; // The name of the scene you want to display after import.
const welcomeJournalEntry = 'RoS - Core - How To Use This Module'; // The name of a journal entry you want to display after import.
const moduleFlag = 'symbaroum5ecore'; // The module specific flag given in the export script
const requiredSystemVersion = '1.5.6';
export const moduleVersion = '0.0.1';

// Added a new type of 'skipimport' so if you do not want to have a particular pack imprted just include it in the list using 'PACK NAME': 'skipimport',
// This is for the use case where you link directly to assets in the compendium so do not want to imrt the contents.
// but all packs must be inclued in moduleFolderNameDict.

const moduleFolderNameDict = {
  'Symbaroum RoS - How to': 'Symbaroum RoS - How to',
  'Symbaroum RoS - GM Aids': 'Symbaroum RoS - GM Aids',
};

// This object is intended to be used to convert the module pack names back to "Folder names".
// It is referenced against the manifest.json so it is important that the key is the pack name and the value is the folder name.
/**
 * @description This class is responsible for presenting a Dialog that prompts for importing the content of the modules.
 * @extends Dialog A FormApplication class in Foundry VTT responsible for creating pop-up dialogues.
 */
export class ModuleImportDialog extends Dialog {
  constructor() {
    super({
      title: `Import ${moduleTitle}`,
      content: ` 
      <img src="modules/symbaroum5ecore/images/journal/symbaroum_onelayer.webp" style="height:127px; width:384px; border:0;" />
      <p><b>Initialize Symbaroum RPG - Symbaroum 5E Ruins of Symbaroum - Core System?</b><br><br>
      This will import the RoS - Core - How To Use This Module user guide</p>
      <p>
      No part of this publication may be reproduced, distributed, stored in a retrieval system, or transmitted in any form by any means, electronic, mechanical, photocopying, recording or otherwise without the prior permission of the publishers.<br><br>
            <br>
      Published by: <b>Free League Publishing</b><br>
      Foundry Conversion by <b>Matthew Haentschke and Paul Watson</b><br>
      
      <a href="https://frialigan.se/">Free League</a> <br><br>
      Module Version: ${moduleVersion}
      <br><br>`,
      buttons: {
        initialize: {
          label: 'Import',
          callback: async () => {
            await this.checkVersion().catch(() => {
              throw console.warn('Version check failed.');
            });
            // await this.checkStarterSet();
            await new ModuleImportDialog().prepareModule().catch((e) => {
              let error = console.error('Failed to initialize module', e);
              throw error;
            });
            await this.renderWelcome();
            game.settings.set(moduleKey, 'imported', true);
            ui.notifications.notify('Import complete. No Issues.');
          },
        },
        cancel: {
          label: 'Cancel',
          callback: () => {
            game.settings.set(moduleKey, 'imported', true);
            // game.settings.set(moduleKey, 'migrationVersion', game.modules.get(moduleKey).data.version);
            ui.notifications.notify("Canceled importing content. You can always import the compendiums through the Module's settings menu.");
          },
        },
      },
    });
    this.imported = {
      Actor: {},
      Item: {},
      JournalEntry: {},
      RollTable: {},
      Scene: {},
    };
  }
  async prepareModule() {
    const manifest = await this.readManifest(packageManifest);
    const modulePacks = await game.modules.get(moduleKey).packs;
    console.warn('Starting import of: ', moduleTitle);
    ui.notifications.notify('Starting import of: ' + moduleTitle + '. Hold on, this could take a while...');
    await this.importModule(manifest, modulePacks, moduleFolderNameDict);
    // await this.performFlagUpdates();
  }

  async importModule(manifest, modulePacks, moduleFolderNameDict) {
    return Promise.all(
      modulePacks.map(async (p) => {
        let moduleFolderId = '';
        let type = '';
        const pack = await game.packs.get(moduleKey + '.' + p.name).getDocuments();
        // V9 change
        if (isNewerVersion(game.version, '0.8.9')) {
          type = p.type;
        } else {
          type = p.entity;
        }

        if (type !== 'Playlist' && type !== 'Macro') {
          const moduleFolderName = moduleFolderNameDict[p.label];
          if (moduleFolderName === 'skipimport') {
            return;
          }
          if (game.folders.getName(moduleFolderName)) {
            moduleFolderId = game.folders.getName(moduleFolderName);
          } else {
            moduleFolderId = await Folder.create({
              name: moduleFolderName,
              type: type,
              parent: null,
              color: manifest[type][moduleFolderName].color || null,
              sort: manifest[type][moduleFolderName].sort || null,
              sorting: manifest[type][moduleFolderName].sorting || 'a',
            });
          }
          // debugger;
          const manifestEntity = manifest[type][moduleFolderName].content;
          await this.importFromManifest(manifestEntity, pack, type, moduleFolderId.data._id);
        } else if (type === 'Playlist') {
          const uniquePlaylists = pack.filter((p) => {
            if (!game.playlists.find((n) => n.data.name === p.data.name)) return p;
          });
          Playlist.create(uniquePlaylists.map((p) => p.data));
        } else {
          const uniqueMacros = pack.filter((p) => {
            if (!game.macros.find((n) => n.data.name === p.data.name)) return p;
          });
          Macro.create(uniqueMacros.map((p) => p.data));
        }
        return true;
      })
    );
  }

  async importFromManifest(manifest, pack, type, parent) {
    let folder = ';';
    if (manifest.parent) {
      parent = manifest.parent;
      delete manifest.parent;
    }
    for await (const [key, item] of Object.entries(manifest)) {
      if (key !== 'entities') {
        if (game.folders.getName(key)) {
          folder = game.folders.getName(key);
        } else {
          folder = await Folder.create({
            name: key,
            type: type,
            color: item.color,
            parent: parent || null,
            sort: item.sort || null,
            sorting: item.sorting || 'a',
          });
        }
        const pushParent = Object.values(item);
        await pushParent.forEach((child) => {
          if (child && typeof child === 'object') child.parent = folder.data._id;
        });
        await this.importFromManifest(item.content, pack, type);
      } else if (key === 'entities') {
        try {
          // debugger;
          const entityData = Object.keys(item).reduce((result, identifier) => {
            const entity = pack.filter((e) => e.data._id === identifier);
            return [...result, entity[0].data];
          }, []);

          for (let index = entityData.length - 1; index >= 0; index--) {
            let x = entityData[index];
            let fred = x.document.collectionName;
            if (game[fred].get(x._id) != undefined) {
              console.log(x.name, ' Exists', fred);
              delete entityData[index];
            }
          }
          let newentityData = entityData.filter(() => true);

          for await (const entry of newentityData) {
            entry._source.folder = parent || null;
          }

          const cls = getDocumentClass(type);
          const createdEntities = await cls.createDocuments(newentityData, { keepId: true });
          if (Array.isArray(createdEntities)) {
            for await (const entry of createdEntities) {
              this.imported[type][entry.data.name] = entry;
            }
          } else {
            this.imported[type][createdEntities.data.name] = createdEntities;
          }
        } catch (e) {
          console.warn('Could not create entity: ', e);
        }
      } else {
        console.error("I don't understand this key: ", key);
      }
    }
  }
  async performFlagUpdates() {
    const entityTypes = ['actors', 'items', 'journal', 'scenes', 'tables'];
    for await (const entityType of entityTypes) {
      switch (entityType) {
        case 'scenes':
          // eslint-disable-next-line no-case-declarations
          const sceneData = [];
          for await (const entity of Object.values(this.imported.Scene)) {
            sceneData.push({
              _id: entity.data._id,
              thumb: entity.data.thumb,
            });
          }
          await Scene.updateDocuments(sceneData);
          break;
        case 'journal':
          // eslint-disable-next-line no-case-declarations
          const journalData = duplicate(Object.values(this.imported.JournalEntry));
          for (const journalEntry of journalData) {
            const flag = journalEntry.data?.flags[moduleFlag]?.folder.sort;
            if (flag) await journalEntry.updateDocuments('sort', flag);
          }
          break;
      }
    }
  }

  async checkVersion() {
    const current = game.system.data.version;
    const required = requiredSystemVersion;
    if (current < required) {
      throw Dialog.prompt({
        title: 'Version Check',
        content: `<h2>Failed to Import</h2><p>Your DnD5e - Fith Edition System system version (${current})is below the minimum required version (${required}).</p><p>Please update your system before proceeding.</p>`,
        label: 'Okay!',
        callback: () => ui.notifications.warn('Aborted importing of compendium content. Update your system and try again.'),
      });
    }
  }

  async readManifest(manifestName) {
    const r = await (await fetch(`modules/${moduleKey}/manifests/${manifestName}`))
      .json()
      .catch((e) => console.warn('MANIFEST ERROR: \nYou likely have nothing in your manifest, or it may be improperly formatted.', e));
    return r;
  }

  async renderWelcome() {
    setTimeout(() => {
      try {
        game.scenes.getName(sceneToActivate).activate();
        // game.journal.getName(welcomeJournalEntry).sheet.render(true, { sheetMode: 'text' });
        Dialog.prompt({
          title: 'Symbaroum RPG - Ruins of Symbaroum Importer',
          content: '<p>Welcome to the <strong>Symbaroum 5E Ruins of Symbaroum - Core System</strong> <br><br> All assets have been imported.',
          label: 'Okay!',
          callback: () => game.journal.getName(welcomeJournalEntry).show(),
        });
      } catch (e) {
        console.error("Couldn't initialize welcome: ", e);
      }
    }, 500);
  }
}
